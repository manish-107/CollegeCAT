// This file is auto-generated by @hey-api/openapi-ts

import { type Options, signinRedirect, completeSignup, logoutUser, getCurrentUser, getByUserEmail, getAllUsers, getUserById, updateUserDetails, deleteUser, createYearWithBatch, getYearsWithBatches, getBatchesByYearId, createBatchForYear, deleteYear, updateYearAndBatches, createSubject, getSubjectsByYear, deleteSubject, getSubjectById, updateSubject, deleteBatch, submitFacultyPriorities, updateFacultyPriorities, deleteFacultyPriority, getPrioritiesByFacultyAndYear, getPriorityByFacultyYearSubjectBatch, getAllPrioritiesByYear, autoAllocateSubjectsForYear, getAllocatedOrderedBySeniority, getAllocationsByYear, updateAllocations, getAllTimetableFormats, createTimetableFormat, getTimetableFormatsByYear, getTimetableFormatsByYearAndBatch, deleteTimetableFormat, getTimetableFormatById, updateTimetableFormat, createTimetableModule, getTimetablesByYear, getTimetableByYearAndBatch, deleteTimetableModule, getTimetableById, updateTimetableModule, createWorkflowStage, getWorkflowStageByYear, incrementWorkflowStep, completeWorkflow, sayHelloGet } from '../sdk.gen';
import { queryOptions, type UseMutationOptions } from '@tanstack/react-query';
import type { SigninRedirectData, CompleteSignupData, CompleteSignupError, LogoutUserData, GetCurrentUserData, GetByUserEmailData, GetAllUsersData, GetUserByIdData, UpdateUserDetailsData, UpdateUserDetailsError, UpdateUserDetailsResponse, DeleteUserData, DeleteUserError, DeleteUserResponse, CreateYearWithBatchData, CreateYearWithBatchError, CreateYearWithBatchResponse, GetYearsWithBatchesData, GetBatchesByYearIdData, CreateBatchForYearData, CreateBatchForYearError, CreateBatchForYearResponse, DeleteYearData, DeleteYearError, DeleteYearResponse, UpdateYearAndBatchesData, UpdateYearAndBatchesError, UpdateYearAndBatchesResponse, CreateSubjectData, CreateSubjectError, CreateSubjectResponse, GetSubjectsByYearData, DeleteSubjectData, DeleteSubjectError, DeleteSubjectResponse, GetSubjectByIdData, UpdateSubjectData, UpdateSubjectError, UpdateSubjectResponse, DeleteBatchData, DeleteBatchError, DeleteBatchResponse, SubmitFacultyPrioritiesData, SubmitFacultyPrioritiesError, SubmitFacultyPrioritiesResponse, UpdateFacultyPrioritiesData, UpdateFacultyPrioritiesError, UpdateFacultyPrioritiesResponse, DeleteFacultyPriorityData, DeleteFacultyPriorityError, DeleteFacultyPriorityResponse, GetPrioritiesByFacultyAndYearData, GetPriorityByFacultyYearSubjectBatchData, GetAllPrioritiesByYearData, AutoAllocateSubjectsForYearData, AutoAllocateSubjectsForYearError, AutoAllocateSubjectsForYearResponse, GetAllocatedOrderedBySeniorityData, GetAllocationsByYearData, UpdateAllocationsData, UpdateAllocationsError, UpdateAllocationsResponse, GetAllTimetableFormatsData, CreateTimetableFormatData, CreateTimetableFormatError, CreateTimetableFormatResponse, GetTimetableFormatsByYearData, GetTimetableFormatsByYearAndBatchData, DeleteTimetableFormatData, DeleteTimetableFormatError, DeleteTimetableFormatResponse, GetTimetableFormatByIdData, UpdateTimetableFormatData, UpdateTimetableFormatError, UpdateTimetableFormatResponse, CreateTimetableModuleData, CreateTimetableModuleError, CreateTimetableModuleResponse, GetTimetablesByYearData, GetTimetableByYearAndBatchData, DeleteTimetableModuleData, DeleteTimetableModuleError, DeleteTimetableModuleResponse, GetTimetableByIdData, UpdateTimetableModuleData, UpdateTimetableModuleError, UpdateTimetableModuleResponse, CreateWorkflowStageData, CreateWorkflowStageError, CreateWorkflowStageResponse, GetWorkflowStageByYearData, IncrementWorkflowStepData, IncrementWorkflowStepError, CompleteWorkflowData, CompleteWorkflowError, CompleteWorkflowResponse, SayHelloGetData } from '../types.gen';
import type { AxiosError } from 'axios';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: (options?.client ?? _heyApiClient).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const signinRedirectQueryKey = (options?: Options<SigninRedirectData>) => createQueryKey('signinRedirect', options);

/**
 * Signin Redirect
 */
export const signinRedirectOptions = (options?: Options<SigninRedirectData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await signinRedirect({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: signinRedirectQueryKey(options)
    });
};

export const completeSignupQueryKey = (options: Options<CompleteSignupData>) => createQueryKey('completeSignup', options);

/**
 * Complete Signup
 */
export const completeSignupOptions = (options: Options<CompleteSignupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await completeSignup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: completeSignupQueryKey(options)
    });
};

/**
 * Complete Signup
 */
export const completeSignupMutation = (options?: Partial<Options<CompleteSignupData>>): UseMutationOptions<unknown, AxiosError<CompleteSignupError>, Options<CompleteSignupData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<CompleteSignupError>, Options<CompleteSignupData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await completeSignup({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const logoutUserQueryKey = (options?: Options<LogoutUserData>) => createQueryKey('logoutUser', options);

/**
 * Logout User
 */
export const logoutUserOptions = (options?: Options<LogoutUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await logoutUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: logoutUserQueryKey(options)
    });
};

export const getCurrentUserQueryKey = (options?: Options<GetCurrentUserData>) => createQueryKey('getCurrentUser', options);

/**
 * Get Current User
 */
export const getCurrentUserOptions = (options?: Options<GetCurrentUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCurrentUserQueryKey(options)
    });
};

export const getByUserEmailQueryKey = (options: Options<GetByUserEmailData>) => createQueryKey('getByUserEmail', options);

/**
 * Get By User Email
 */
export const getByUserEmailOptions = (options: Options<GetByUserEmailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getByUserEmail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getByUserEmailQueryKey(options)
    });
};

export const getAllUsersQueryKey = (options?: Options<GetAllUsersData>) => createQueryKey('getAllUsers', options);

/**
 * Get All Users
 * Get all users with their details.
 *
 * Returns a list of all users in the system with complete user information.
 */
export const getAllUsersOptions = (options?: Options<GetAllUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllUsersQueryKey(options)
    });
};

export const getUserByIdQueryKey = (options: Options<GetUserByIdData>) => createQueryKey('getUserById', options);

/**
 * Get User By Id
 * Get user by ID.
 *
 * - **user_id**: ID of the user to retrieve
 *
 * Returns the user details if found, otherwise returns 404.
 */
export const getUserByIdOptions = (options: Options<GetUserByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserByIdQueryKey(options)
    });
};

/**
 * Update User Details
 */
export const updateUserDetailsMutation = (options?: Partial<Options<UpdateUserDetailsData>>): UseMutationOptions<UpdateUserDetailsResponse, AxiosError<UpdateUserDetailsError>, Options<UpdateUserDetailsData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserDetailsResponse, AxiosError<UpdateUserDetailsError>, Options<UpdateUserDetailsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserDetails({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User
 */
export const deleteUserMutation = (options?: Partial<Options<DeleteUserData>>): UseMutationOptions<DeleteUserResponse, AxiosError<DeleteUserError>, Options<DeleteUserData>> => {
    const mutationOptions: UseMutationOptions<DeleteUserResponse, AxiosError<DeleteUserError>, Options<DeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createYearWithBatchQueryKey = (options: Options<CreateYearWithBatchData>) => createQueryKey('createYearWithBatch', options);

/**
 * Create Year With Batch
 */
export const createYearWithBatchOptions = (options: Options<CreateYearWithBatchData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createYearWithBatch({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createYearWithBatchQueryKey(options)
    });
};

/**
 * Create Year With Batch
 */
export const createYearWithBatchMutation = (options?: Partial<Options<CreateYearWithBatchData>>): UseMutationOptions<CreateYearWithBatchResponse, AxiosError<CreateYearWithBatchError>, Options<CreateYearWithBatchData>> => {
    const mutationOptions: UseMutationOptions<CreateYearWithBatchResponse, AxiosError<CreateYearWithBatchError>, Options<CreateYearWithBatchData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createYearWithBatch({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getYearsWithBatchesQueryKey = (options?: Options<GetYearsWithBatchesData>) => createQueryKey('getYearsWithBatches', options);

/**
 * Get Years With Batches
 */
export const getYearsWithBatchesOptions = (options?: Options<GetYearsWithBatchesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getYearsWithBatches({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getYearsWithBatchesQueryKey(options)
    });
};

export const getBatchesByYearIdQueryKey = (options: Options<GetBatchesByYearIdData>) => createQueryKey('getBatchesByYearId', options);

/**
 * Get Batches By Year Id
 */
export const getBatchesByYearIdOptions = (options: Options<GetBatchesByYearIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBatchesByYearId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBatchesByYearIdQueryKey(options)
    });
};

export const createBatchForYearQueryKey = (options: Options<CreateBatchForYearData>) => createQueryKey('createBatchForYear', options);

/**
 * Create Batch For Year
 */
export const createBatchForYearOptions = (options: Options<CreateBatchForYearData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createBatchForYear({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createBatchForYearQueryKey(options)
    });
};

/**
 * Create Batch For Year
 */
export const createBatchForYearMutation = (options?: Partial<Options<CreateBatchForYearData>>): UseMutationOptions<CreateBatchForYearResponse, AxiosError<CreateBatchForYearError>, Options<CreateBatchForYearData>> => {
    const mutationOptions: UseMutationOptions<CreateBatchForYearResponse, AxiosError<CreateBatchForYearError>, Options<CreateBatchForYearData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createBatchForYear({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Year
 */
export const deleteYearMutation = (options?: Partial<Options<DeleteYearData>>): UseMutationOptions<DeleteYearResponse, AxiosError<DeleteYearError>, Options<DeleteYearData>> => {
    const mutationOptions: UseMutationOptions<DeleteYearResponse, AxiosError<DeleteYearError>, Options<DeleteYearData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteYear({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Year And Batches
 */
export const updateYearAndBatchesMutation = (options?: Partial<Options<UpdateYearAndBatchesData>>): UseMutationOptions<UpdateYearAndBatchesResponse, AxiosError<UpdateYearAndBatchesError>, Options<UpdateYearAndBatchesData>> => {
    const mutationOptions: UseMutationOptions<UpdateYearAndBatchesResponse, AxiosError<UpdateYearAndBatchesError>, Options<UpdateYearAndBatchesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateYearAndBatches({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createSubjectQueryKey = (options: Options<CreateSubjectData>) => createQueryKey('createSubject', options);

/**
 * Create Subject
 */
export const createSubjectOptions = (options: Options<CreateSubjectData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSubject({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSubjectQueryKey(options)
    });
};

/**
 * Create Subject
 */
export const createSubjectMutation = (options?: Partial<Options<CreateSubjectData>>): UseMutationOptions<CreateSubjectResponse, AxiosError<CreateSubjectError>, Options<CreateSubjectData>> => {
    const mutationOptions: UseMutationOptions<CreateSubjectResponse, AxiosError<CreateSubjectError>, Options<CreateSubjectData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createSubject({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSubjectsByYearQueryKey = (options: Options<GetSubjectsByYearData>) => createQueryKey('getSubjectsByYear', options);

/**
 * Get Subjects By Year
 */
export const getSubjectsByYearOptions = (options: Options<GetSubjectsByYearData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSubjectsByYear({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSubjectsByYearQueryKey(options)
    });
};

/**
 * Delete Subject
 */
export const deleteSubjectMutation = (options?: Partial<Options<DeleteSubjectData>>): UseMutationOptions<DeleteSubjectResponse, AxiosError<DeleteSubjectError>, Options<DeleteSubjectData>> => {
    const mutationOptions: UseMutationOptions<DeleteSubjectResponse, AxiosError<DeleteSubjectError>, Options<DeleteSubjectData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteSubject({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSubjectByIdQueryKey = (options: Options<GetSubjectByIdData>) => createQueryKey('getSubjectById', options);

/**
 * Get Subject By Id
 */
export const getSubjectByIdOptions = (options: Options<GetSubjectByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSubjectById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSubjectByIdQueryKey(options)
    });
};

/**
 * Update Subject
 */
export const updateSubjectMutation = (options?: Partial<Options<UpdateSubjectData>>): UseMutationOptions<UpdateSubjectResponse, AxiosError<UpdateSubjectError>, Options<UpdateSubjectData>> => {
    const mutationOptions: UseMutationOptions<UpdateSubjectResponse, AxiosError<UpdateSubjectError>, Options<UpdateSubjectData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSubject({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Batch
 */
export const deleteBatchMutation = (options?: Partial<Options<DeleteBatchData>>): UseMutationOptions<DeleteBatchResponse, AxiosError<DeleteBatchError>, Options<DeleteBatchData>> => {
    const mutationOptions: UseMutationOptions<DeleteBatchResponse, AxiosError<DeleteBatchError>, Options<DeleteBatchData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteBatch({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const submitFacultyPrioritiesQueryKey = (options: Options<SubmitFacultyPrioritiesData>) => createQueryKey('submitFacultyPriorities', options);

/**
 * Submit Priorities
 * Submit faculty subject priorities for a year
 */
export const submitFacultyPrioritiesOptions = (options: Options<SubmitFacultyPrioritiesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await submitFacultyPriorities({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: submitFacultyPrioritiesQueryKey(options)
    });
};

/**
 * Submit Priorities
 * Submit faculty subject priorities for a year
 */
export const submitFacultyPrioritiesMutation = (options?: Partial<Options<SubmitFacultyPrioritiesData>>): UseMutationOptions<SubmitFacultyPrioritiesResponse, AxiosError<SubmitFacultyPrioritiesError>, Options<SubmitFacultyPrioritiesData>> => {
    const mutationOptions: UseMutationOptions<SubmitFacultyPrioritiesResponse, AxiosError<SubmitFacultyPrioritiesError>, Options<SubmitFacultyPrioritiesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await submitFacultyPriorities({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Priorities
 * Update faculty subject priorities by swapping priorities between two subjects
 */
export const updateFacultyPrioritiesMutation = (options?: Partial<Options<UpdateFacultyPrioritiesData>>): UseMutationOptions<UpdateFacultyPrioritiesResponse, AxiosError<UpdateFacultyPrioritiesError>, Options<UpdateFacultyPrioritiesData>> => {
    const mutationOptions: UseMutationOptions<UpdateFacultyPrioritiesResponse, AxiosError<UpdateFacultyPrioritiesError>, Options<UpdateFacultyPrioritiesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateFacultyPriorities({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Priority
 * Delete a specific priority entry
 */
export const deleteFacultyPriorityMutation = (options?: Partial<Options<DeleteFacultyPriorityData>>): UseMutationOptions<DeleteFacultyPriorityResponse, AxiosError<DeleteFacultyPriorityError>, Options<DeleteFacultyPriorityData>> => {
    const mutationOptions: UseMutationOptions<DeleteFacultyPriorityResponse, AxiosError<DeleteFacultyPriorityError>, Options<DeleteFacultyPriorityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteFacultyPriority({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPrioritiesByFacultyAndYearQueryKey = (options: Options<GetPrioritiesByFacultyAndYearData>) => createQueryKey('getPrioritiesByFacultyAndYear', options);

/**
 * Get Priorities By Faculty And Year
 * Get all priorities for a specific faculty and year
 */
export const getPrioritiesByFacultyAndYearOptions = (options: Options<GetPrioritiesByFacultyAndYearData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPrioritiesByFacultyAndYear({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPrioritiesByFacultyAndYearQueryKey(options)
    });
};

export const getPriorityByFacultyYearSubjectBatchQueryKey = (options: Options<GetPriorityByFacultyYearSubjectBatchData>) => createQueryKey('getPriorityByFacultyYearSubjectBatch', options);

/**
 * Get Priority By Faculty Year Subject Batch
 * Get a specific priority for a faculty, year, subject, and batch combination
 */
export const getPriorityByFacultyYearSubjectBatchOptions = (options: Options<GetPriorityByFacultyYearSubjectBatchData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPriorityByFacultyYearSubjectBatch({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPriorityByFacultyYearSubjectBatchQueryKey(options)
    });
};

export const getAllPrioritiesByYearQueryKey = (options: Options<GetAllPrioritiesByYearData>) => createQueryKey('getAllPrioritiesByYear', options);

/**
 * Get All Priorities By Year
 * Get all priorities for a year with detailed information
 */
export const getAllPrioritiesByYearOptions = (options: Options<GetAllPrioritiesByYearData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllPrioritiesByYear({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllPrioritiesByYearQueryKey(options)
    });
};

export const autoAllocateSubjectsForYearQueryKey = (options: Options<AutoAllocateSubjectsForYearData>) => createQueryKey('autoAllocateSubjectsForYear', options);

/**
 * Auto Allocate Subjects For Year
 * Automatically allocate subjects to faculty based on priorities and seniority
 */
export const autoAllocateSubjectsForYearOptions = (options: Options<AutoAllocateSubjectsForYearData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await autoAllocateSubjectsForYear({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: autoAllocateSubjectsForYearQueryKey(options)
    });
};

/**
 * Auto Allocate Subjects For Year
 * Automatically allocate subjects to faculty based on priorities and seniority
 */
export const autoAllocateSubjectsForYearMutation = (options?: Partial<Options<AutoAllocateSubjectsForYearData>>): UseMutationOptions<AutoAllocateSubjectsForYearResponse, AxiosError<AutoAllocateSubjectsForYearError>, Options<AutoAllocateSubjectsForYearData>> => {
    const mutationOptions: UseMutationOptions<AutoAllocateSubjectsForYearResponse, AxiosError<AutoAllocateSubjectsForYearError>, Options<AutoAllocateSubjectsForYearData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await autoAllocateSubjectsForYear({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllocatedOrderedBySeniorityQueryKey = (options: Options<GetAllocatedOrderedBySeniorityData>) => createQueryKey('getAllocatedOrderedBySeniority', options);

/**
 * Get Allocated Ordered By Seniority
 * Get allocations grouped by year, batches, and subjects with allocated faculty
 */
export const getAllocatedOrderedBySeniorityOptions = (options: Options<GetAllocatedOrderedBySeniorityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllocatedOrderedBySeniority({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllocatedOrderedBySeniorityQueryKey(options)
    });
};

export const getAllocationsByYearQueryKey = (options: Options<GetAllocationsByYearData>) => createQueryKey('getAllocationsByYear', options);

/**
 * Get Allocations By Year
 * Get all allocations for a specific year with details
 */
export const getAllocationsByYearOptions = (options: Options<GetAllocationsByYearData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllocationsByYear({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllocationsByYearQueryKey(options)
    });
};

/**
 * Update Allocations By Year And Batch
 * Update allocation by year_id and batch_id
 */
export const updateAllocationsMutation = (options?: Partial<Options<UpdateAllocationsData>>): UseMutationOptions<UpdateAllocationsResponse, AxiosError<UpdateAllocationsError>, Options<UpdateAllocationsData>> => {
    const mutationOptions: UseMutationOptions<UpdateAllocationsResponse, AxiosError<UpdateAllocationsError>, Options<UpdateAllocationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateAllocations({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllTimetableFormatsQueryKey = (options?: Options<GetAllTimetableFormatsData>) => createQueryKey('getAllTimetableFormats', options);

/**
 * Get All Timetable Formats
 * Get all timetable formats.
 */
export const getAllTimetableFormatsOptions = (options?: Options<GetAllTimetableFormatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllTimetableFormats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllTimetableFormatsQueryKey(options)
    });
};

export const createTimetableFormatQueryKey = (options: Options<CreateTimetableFormatData>) => createQueryKey('createTimetableFormat', options);

/**
 * Create Timetable Format
 * Create a new timetable format.
 *
 * - **year_id**: ID of the academic year
 * - **batch_id**: ID of the batch
 * - **format_name**: Name of the timetable format
 * - **format_data**: JSON data containing the timetable format structure
 */
export const createTimetableFormatOptions = (options: Options<CreateTimetableFormatData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTimetableFormat({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTimetableFormatQueryKey(options)
    });
};

/**
 * Create Timetable Format
 * Create a new timetable format.
 *
 * - **year_id**: ID of the academic year
 * - **batch_id**: ID of the batch
 * - **format_name**: Name of the timetable format
 * - **format_data**: JSON data containing the timetable format structure
 */
export const createTimetableFormatMutation = (options?: Partial<Options<CreateTimetableFormatData>>): UseMutationOptions<CreateTimetableFormatResponse, AxiosError<CreateTimetableFormatError>, Options<CreateTimetableFormatData>> => {
    const mutationOptions: UseMutationOptions<CreateTimetableFormatResponse, AxiosError<CreateTimetableFormatError>, Options<CreateTimetableFormatData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTimetableFormat({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTimetableFormatsByYearQueryKey = (options: Options<GetTimetableFormatsByYearData>) => createQueryKey('getTimetableFormatsByYear', options);

/**
 * Get Timetable Formats By Year
 * Get all timetable formats for a specific academic year.
 *
 * - **year_id**: ID of the academic year
 */
export const getTimetableFormatsByYearOptions = (options: Options<GetTimetableFormatsByYearData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTimetableFormatsByYear({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTimetableFormatsByYearQueryKey(options)
    });
};

export const getTimetableFormatsByYearAndBatchQueryKey = (options: Options<GetTimetableFormatsByYearAndBatchData>) => createQueryKey('getTimetableFormatsByYearAndBatch', options);

/**
 * Get Timetable Formats By Year And Batch
 * Get all timetable formats for a specific academic year and batch.
 *
 * - **year_id**: ID of the academic year
 * - **batch_id**: ID of the batch
 */
export const getTimetableFormatsByYearAndBatchOptions = (options: Options<GetTimetableFormatsByYearAndBatchData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTimetableFormatsByYearAndBatch({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTimetableFormatsByYearAndBatchQueryKey(options)
    });
};

/**
 * Delete Timetable Format
 * Delete a timetable format.
 *
 * - **format_id**: ID of the timetable format to delete
 */
export const deleteTimetableFormatMutation = (options?: Partial<Options<DeleteTimetableFormatData>>): UseMutationOptions<DeleteTimetableFormatResponse, AxiosError<DeleteTimetableFormatError>, Options<DeleteTimetableFormatData>> => {
    const mutationOptions: UseMutationOptions<DeleteTimetableFormatResponse, AxiosError<DeleteTimetableFormatError>, Options<DeleteTimetableFormatData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTimetableFormat({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTimetableFormatByIdQueryKey = (options: Options<GetTimetableFormatByIdData>) => createQueryKey('getTimetableFormatById', options);

/**
 * Get Timetable Format By Id
 * Get a specific timetable format by ID.
 *
 * - **format_id**: ID of the timetable format
 */
export const getTimetableFormatByIdOptions = (options: Options<GetTimetableFormatByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTimetableFormatById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTimetableFormatByIdQueryKey(options)
    });
};

/**
 * Update Timetable Format
 * Update a timetable format.
 *
 * - **format_id**: ID of the timetable format to update
 * - **format_name**: Updated name of the timetable format (optional)
 * - **format_data**: Updated JSON data containing the timetable format structure (optional)
 */
export const updateTimetableFormatMutation = (options?: Partial<Options<UpdateTimetableFormatData>>): UseMutationOptions<UpdateTimetableFormatResponse, AxiosError<UpdateTimetableFormatError>, Options<UpdateTimetableFormatData>> => {
    const mutationOptions: UseMutationOptions<UpdateTimetableFormatResponse, AxiosError<UpdateTimetableFormatError>, Options<UpdateTimetableFormatData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTimetableFormat({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createTimetableModuleQueryKey = (options: Options<CreateTimetableModuleData>) => createQueryKey('createTimetableModule', options);

/**
 * Create Timetable Module
 * Create a new timetable module.
 *
 * - **format_id**: ID of the timetable format to use
 * - **year_id**: ID of the academic year
 * - **batch_id**: ID of the batch
 * - **timetable_data**: JSON structure containing daily subject schedules
 *
 * Returns the created timetable module with all related details.
 */
export const createTimetableModuleOptions = (options: Options<CreateTimetableModuleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTimetableModule({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTimetableModuleQueryKey(options)
    });
};

/**
 * Create Timetable Module
 * Create a new timetable module.
 *
 * - **format_id**: ID of the timetable format to use
 * - **year_id**: ID of the academic year
 * - **batch_id**: ID of the batch
 * - **timetable_data**: JSON structure containing daily subject schedules
 *
 * Returns the created timetable module with all related details.
 */
export const createTimetableModuleMutation = (options?: Partial<Options<CreateTimetableModuleData>>): UseMutationOptions<CreateTimetableModuleResponse, AxiosError<CreateTimetableModuleError>, Options<CreateTimetableModuleData>> => {
    const mutationOptions: UseMutationOptions<CreateTimetableModuleResponse, AxiosError<CreateTimetableModuleError>, Options<CreateTimetableModuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTimetableModule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTimetablesByYearQueryKey = (options: Options<GetTimetablesByYearData>) => createQueryKey('getTimetablesByYear', options);

/**
 * Get Timetables By Year
 * Get all timetable modules for a specific academic year.
 *
 * - **year_id**: ID of the academic year
 *
 * Returns all timetables for the year with batch details, format details, and timetable details.
 */
export const getTimetablesByYearOptions = (options: Options<GetTimetablesByYearData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTimetablesByYear({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTimetablesByYearQueryKey(options)
    });
};

export const getTimetableByYearAndBatchQueryKey = (options: Options<GetTimetableByYearAndBatchData>) => createQueryKey('getTimetableByYearAndBatch', options);

/**
 * Get Timetable By Year And Batch
 * Get timetable module for a specific year and batch.
 *
 * - **year_id**: ID of the academic year
 * - **batch_id**: ID of the batch
 *
 * Returns the timetable with batch details, format details, and timetable details.
 */
export const getTimetableByYearAndBatchOptions = (options: Options<GetTimetableByYearAndBatchData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTimetableByYearAndBatch({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTimetableByYearAndBatchQueryKey(options)
    });
};

/**
 * Delete Timetable Module
 * Delete a timetable module.
 *
 * - **timetable_id**: ID of the timetable to delete
 *
 * Returns confirmation of deletion.
 */
export const deleteTimetableModuleMutation = (options?: Partial<Options<DeleteTimetableModuleData>>): UseMutationOptions<DeleteTimetableModuleResponse, AxiosError<DeleteTimetableModuleError>, Options<DeleteTimetableModuleData>> => {
    const mutationOptions: UseMutationOptions<DeleteTimetableModuleResponse, AxiosError<DeleteTimetableModuleError>, Options<DeleteTimetableModuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTimetableModule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTimetableByIdQueryKey = (options: Options<GetTimetableByIdData>) => createQueryKey('getTimetableById', options);

/**
 * Get Timetable By Id
 * Get timetable module by ID.
 *
 * - **timetable_id**: ID of the timetable
 *
 * Returns the timetable with all related details.
 */
export const getTimetableByIdOptions = (options: Options<GetTimetableByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTimetableById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTimetableByIdQueryKey(options)
    });
};

/**
 * Update Timetable Module
 * Update a timetable module.
 *
 * - **timetable_id**: ID of the timetable to update
 * - **timetable_data**: Updated JSON structure containing daily subject schedules
 *
 * Returns the updated timetable module with all related details.
 */
export const updateTimetableModuleMutation = (options?: Partial<Options<UpdateTimetableModuleData>>): UseMutationOptions<UpdateTimetableModuleResponse, AxiosError<UpdateTimetableModuleError>, Options<UpdateTimetableModuleData>> => {
    const mutationOptions: UseMutationOptions<UpdateTimetableModuleResponse, AxiosError<UpdateTimetableModuleError>, Options<UpdateTimetableModuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTimetableModule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createWorkflowStageQueryKey = (options: Options<CreateWorkflowStageData>) => createQueryKey('createWorkflowStage', options);

/**
 * Create Workflow Stage
 * Create a new workflow stage for an academic year
 */
export const createWorkflowStageOptions = (options: Options<CreateWorkflowStageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createWorkflowStage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createWorkflowStageQueryKey(options)
    });
};

/**
 * Create Workflow Stage
 * Create a new workflow stage for an academic year
 */
export const createWorkflowStageMutation = (options?: Partial<Options<CreateWorkflowStageData>>): UseMutationOptions<CreateWorkflowStageResponse, AxiosError<CreateWorkflowStageError>, Options<CreateWorkflowStageData>> => {
    const mutationOptions: UseMutationOptions<CreateWorkflowStageResponse, AxiosError<CreateWorkflowStageError>, Options<CreateWorkflowStageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createWorkflowStage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkflowStageByYearQueryKey = (options: Options<GetWorkflowStageByYearData>) => createQueryKey('getWorkflowStageByYear', options);

/**
 * Get Workflow Stage By Year
 * Get workflow stage for a specific academic year
 */
export const getWorkflowStageByYearOptions = (options: Options<GetWorkflowStageByYearData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkflowStageByYear({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkflowStageByYearQueryKey(options)
    });
};

/**
 * Increment Workflow Step
 * Increment the current workflow step by 1
 */
export const incrementWorkflowStepMutation = (options?: Partial<Options<IncrementWorkflowStepData>>): UseMutationOptions<unknown, AxiosError<IncrementWorkflowStepError>, Options<IncrementWorkflowStepData>> => {
    const mutationOptions: UseMutationOptions<unknown, AxiosError<IncrementWorkflowStepError>, Options<IncrementWorkflowStepData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await incrementWorkflowStep({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Complete Workflow
 * Mark workflow as completed
 */
export const completeWorkflowMutation = (options?: Partial<Options<CompleteWorkflowData>>): UseMutationOptions<CompleteWorkflowResponse, AxiosError<CompleteWorkflowError>, Options<CompleteWorkflowData>> => {
    const mutationOptions: UseMutationOptions<CompleteWorkflowResponse, AxiosError<CompleteWorkflowError>, Options<CompleteWorkflowData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await completeWorkflow({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const sayHelloGetQueryKey = (options?: Options<SayHelloGetData>) => createQueryKey('sayHelloGet', options);

/**
 * Say Hello
 */
export const sayHelloGetOptions = (options?: Options<SayHelloGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sayHelloGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sayHelloGetQueryKey(options)
    });
};